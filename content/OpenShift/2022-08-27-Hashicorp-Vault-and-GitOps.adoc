--- 
title: "HashiCorp Vault and GitOps - A declerative way"
description: "Combining Vault and GitOps using the Vault-Config-Operator and ArgoCD Vault Plugin"
date: "2022-08-27"
doctype: book
draft: true

author: Thomas Jungbauer
type: post
categories:
   - OpenShift
   - Day-2
tags: ["OCP", "Day-2", "OpenShift", "Vault", "Secrets", "GitOps", "ArgoCD"] 

aliases: [ 
	 "/openshift/day-2/secrets-management-gitops",
] 
---

:imagesdir: /OpenShift/images/
:icons: font
:toc:

As described in the previous article, sensitive information (Secrets) should be managed by a Secret Management System. In the example we used a MySQL database, which is a static (root) password for example. In best cases, nobody knows this password and it is rotated automatically. While we configured Vault manually the last time, this article focus on a declarative approach using GitOps mechanism wherever it is possible and does make sense. We will use OpenShift-GitOps, based on ArgoCD, to configure static and dynamics Secrets and the ArgoCD Vault Plugin to connect both and let ArgoCD inject secrets into the application.

<!--more--> 

== References

. link:/openshift/day-2/secrets-management-gitops/[Secrets Management - Vault on OpenShift]


== Prerequisites 

. OpenShift and Vault are installed
. Vault must be initialized and unsealed, so that we can connect to it and know the root_token

NOTE: The *Unsealing process* will still be done manually, due to security concerns. Once Vault is unsealed the secrets can be read and usually it is preferable to have control over that. 

== Introduction

There are 2 things we will discuss in this article

. Vault Config Operator, which helps to configure Vault itself
.	ArgoCD Vault Plugin, which pulls the secret from Vault and injects it into the application.

The article link:/openshift/day-2/secrets-management-gitops/[Secrets Management - Vault on OpenShift] explained the installation of Vault using several CLI commands, that can either be called locally (using the vault command and a portforwarding) or by logging in into a Vault contains. Some of these configurations can be done using the Vault Config Operator. The commands configured Kubernetes Auth Method or a Key/Value secrets engine and some of them (not all) can be moved into ArgoCD to make it more declarative and repeatable in sense of a GitOps workflow. 

== Vault Config Operator 

=== Installation 

The installation of the operator is straight forward and can be done via command line or via OpenShift UI: 

Simply select "Vault Config Operator" and install it with the default values. 

In addition to that we need a secret, which tells the operator 2 things using environment variables:

. The address to our Vault server (VAULT_ADDR)
. The token with admin permission to Vault so we can authenticate against (VAULT_TOKEN)

Therefore, the following secret must be created: 

CAUTION: I use the *root_token* at this step. This means that Vault has been initialized and unsealed already. If you have stored this token in a file unseal.json for example, you can copy/paste the code block. More information about initialization and unsealing can be found at: https://blog.stderr.at/openshift/2022-08-16-hashicorp-vault/#_initialize_and_unseal_vault.
It is possible and probably recommended to create a separate token with administrative permissions for the Vault Config Operator so the root_token must not be used. 

oc create --save-config --dry-run=client secret generic vault \
	--from-literal=VAULT_ADDR=http://vault.vault:8200 \
	--from-literal=VAULT_TOKEN=$(shell cat unseal.json | jq -r '.root_token') \
	-o yaml | oc apply --namespace vault-config-operator -f -


=== Using Vault Config Operator

The installed operator provides a bunch of custom resource definitions that allow us to interact with Vault, commit everything into Git and let GitOps manage it. 






Check additional config in Subscription  config env variables are added there (vault_addr, vault_token)



Vault config operator defines a lot of CRDs which helps you to interact with vault 
And comit this to version control and let argo manage them. 

For example: satic password 
Using SecretEngneMount, with name static and path expense, which will mount the secret at expense/static. Authentication via Kubernetes with special user and role “vault-admin” 

Important: SecretEngineMount support KV version 1 only at this moment. 

The idea behind this is to allow applications teams just enough access to configure their secrets at certain paths. 

 difference kv 1 and 2

PasswordPolicy:
Defines the policy of a password (secretFormat) , like length, min upper or lower chars etc. 

RandomSecret: 
Create a secret based upon a PasswordPolicy- You do not need to be aware of any password. In fact, nobody knows the password. Vault will create a random password for you and provides it to the <path>/<name> and even refreshes it.

DatabaseSecretEngineConfig
Used to connect to a databas. It uses… the plugin (mysql-database-plugin), allows a Vault roles (not Kubernetes role) and the connectionstring as well as where to find the randomly generated root password … which we defined with the SecretEngine above. Even when the password is rotated, the connection to the DB will cont. to work as the CRD simply checks for the new password at this path. 

Again, nobody knows the root password. The CRD can be stored in Git without any issues to thing about encrypting it. 


DatabaseSecretEngineRole
Creates a username and password for a database (and table) and grant privileges. 

Policy
Defines API permissions to specific paths. Or example with this policy, you can only read the passwords from the path, but not retrive them (get, list). 

KubernetesAuthEngineRole
 not explained 

There are some things that are not recommended to do declerative. For example the bootstrap policy you might want to create manually for security reasons or give these permissions to external teams so they can setup or prepare Vault for you. 

These things are still done using the vault CLI. 

For example: enabling the Kubernetes Auth method or to create a vault admin policy. 

The Vault admin service account gets linked into the app namespace (expense). It allows this used to configure vault using the operator.

This minimize what a service account can do in vault and to minimize potential issues when one service account gets compromised. 



Vault-admin.hcl
Deines to which paths the user has access and which capabilities are allowd. The admin user 
•	needs access to a certain path expense/*
•	access to create mount sys/mounts /*
•	read mounts 
•	etc. 

set up argocd-plugin
vault config op  is setting up the secrets 
argocd plugin inject the secret into the applications

argocd required its own permissions , therefore we create a new policy with permissions defined in argocd.hcl and bind it to a service account and the namespace. 

The argocd plugin is limited to just read the static password. It does not require access to dynamic password, it just needs to inject the static (root) password. 





