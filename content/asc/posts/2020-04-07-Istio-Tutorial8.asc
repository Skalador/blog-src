{:title "OpenShift 4 and Service Mesh 8 - Fault Injection" 
 :description "OpenShift 4.x and Service Mesh/Istio Tutorial 8 - Faul Injection/Chaos Testing"
 :layout 
 :post 
 :tags ["Istio", "Service Mesh", "OpenShift", "OCP", "Fault Injection"] 
 :toc false 
}

// Asciidoc Parameters
// toc is set here since I like unnumbered tocs more
:author: Thomas Jungbauer
:icons: font
:linkattrs:
:toc: macro

[.small]
_Author: {author} - Last Modified: {docdatetime}_
// Asciidoc Parameters END

Tutorial 8 of *OpenShift 4 and Service Mesh* tries to cover Fault Injection by using Chaos testing method to verify if your application is running. This is done by adding the property HTTPFaultInjection to the VirtualService. The settings for this property can be for example: delay, to delay the access or abort, to completely abort the connection.

"_Adopting microservices often means more dependencies, and more services you might not control. It also means more requests on the network, increasing the possibility for errors. For these reasons, it's important to test your servicesâ€™ behavior when upstream dependencies fail."_ [<<source_1,1>>]

{nbsp} +
{nbsp} +

// Table of Content
toc::[options="nonumbers"]


== Preparation
Before we start this tutorial, we need to clean up our cluster. This is especially important when you did the previous training link:/posts-output/2020-04-06-Istio-Tutorial7[Limit Egress/External Traffic].

[source,bash]
----
oc delete deployment recommendation-v3
oc scale deployment recommendation-v2 --replicas=1
oc delete serviceentry worldclockapi-egress-rule
oc delete virtualservice worldclockapi-timeout
----
{nbsp} +

Verify that 2 pods for the recommendation services are running (with 2 containers)

[.hidecopy]
[source,bash]
----
oc get pods -l app=recommendation -n tutorial
NAME                                 READY   STATUS    RESTARTS   AGE
recommendation-v1-69db8d6c48-h8brv   2/2     Running   0          4d20h
recommendation-v2-6c5b86bbd8-jnk8b   2/2     Running   0          4d19h
----

'''

== Abort Connection with HTTP Error 503
For the first example, we will need to modify the VirtualService and the DestinationRule. The VirtualService must be extended with a http fault section, which will abort the traffic 50% of the time.

. Create the VirtualService
+
[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: recommendation
spec:
  hosts:
  - recommendation
  http:
  - fault:
      abort:
        httpStatus: 503
        percent: 50
    route:
    - destination:
        host: recommendation
        subset: app-recommendation
----
+
{nbsp} +
Apply the change
+
[source,bash]
----
oc replace -f VirtualService-abort.yaml
----
{nbsp} +
+
WARNING: Existing VirtualService with the name recommendation will be overwritten. 

. Create the DestinationRule
+
[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: recommendation
spec:
  host: recommendation
  subsets:
  - labels:
      app: recommendation
    name: app-recommendation
----
+
{nbsp} +
Apply the change
+
[source,bash]
----
oc replace -f destinationrule-faultinj.yaml
----
{nbsp} +
+
WARNING: Existing Destination with the name recommendation will be overwritten. 

. Check the traffic and verify that 50% of the connections will end with a 503 error:
+
[source,bash]
----
export INGRESS_GATEWAY=$(oc get route customer -n tutorial -o 'jsonpath={.spec.host}')
sh ~/run.sh 1000 $GATEWAY_URL
----
{nbsp} +

=== Clean Up
[source,bash]
----
oc delete virtualservice recommendation
----
{nbsp} +

'''

== Test slow connection with Delay 
More interesting, in my opinion, to test is a slow connection. This can be tested by adding the _fixedDelay_ property into the VirtualService. 
Like in the example below, we will use a VirtualService. This time *delay* instead of *abort* is used. The fixDelay defines a delay of 7 seconds for 50% of the traffic.

[source,yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: recommendation
spec:
  hosts:
  - recommendation
  http:
  - fault:
      delay:
        fixedDelay: 7.000s
        percent: 50
    route:
    - destination:
        host: recommendation
        subset: app-recommendation
----
{nbsp} +


If you now send traffic into the application, you will see that some answers will have a delay of 7 seconds. Keep sending traffic in a loop.

Even more visible it will be, when you goto "Distributed Tracing" at the Kiali UI, select the service _recommendation_ and a small lookback of maybe 5min. 
You will find that some requests are very fast, while other will tage about 7 seconds.

.Jaeger with delayed traffic. 
image::/img/servicemesh/Kiali-delayed-traffic.png[Kiali, 940,558, role=bordered]

'''

== Sources
* [[source_1]][1]: https://istiobyexample.dev/fault-injection/[Istio By Example - Fault Injection^]
