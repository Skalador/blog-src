#+title: Adventures in Java Land: JPA a disconnected entities
#+author: Toni Schmidbauer
#+lastmod: [2021-03-04 Thu 12:37]
#+categories[]: Java
#+draft: true
#+variable: value
#+date: 2021-08-27
#+list[]: value_1 value_2 value_3

* Prefix

An old man tries to refresh his Java skills and takes [[https://www.redhat.com/en/services/training/red-hat-cloud-native-microservices-development-quarkus-do378][DO378]]. He fails
spectacularly but learns a lot on the way.

* The exception

There is this basic example where you build a minimal REST API for
storing speaker data in a database. Quarkus makes this quite easy. You
just have to define your database connection properties in
_resources/application.properties_ and off you go developing your Java
Quarkus REST service:

#+begin_src ini
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:mem:default
quarkus.datasource.username=admin
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.log.sql=true
#+end_src

So next we define our entity class to be stored in the database. I
will skip the import statements and any other code not relevant for
this post.

#+begin_src java
// import statements skipped
@Entity
public class Speaker extends PanacheEntity {
    public UUID uuid;

    public String nameFirst;
    public String nameLast;
    public String organization;

    @JsonbTransient
    public String biography;
    public String picture;
    public String twitterHandle;

    // Constructors, getters and setters, toString and other methods skipped
    ....

}
#+end_src

We define an Entity _Speaker_ which extends the [[https://github.com/quarkusio/quarkus/blob/main/extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/PanacheEntity.java][_PanacheEntity_]]
class. [[https://quarkus.io/guides/hibernate-orm-panache][Panache]] is a thin wrapper around [[https://hibernate.org/][Hibernate]] providing a few
convince feature. For example the base class _PanacheEntity_ defines a
autoincrement _Id_ column for us. This inherited _Id_ column of
importance for understanding the problem ahead of us.

So next you define your _SpeakerService_ class which uses the
entity. Once again I will skip the imports and any code not relevant
for understanding the problem:

#+begin_src java
@ApplicationScoped
public class SpeakerService {

    public Speaker create(Speaker speaker) {
        speaker.persist();
        return speaker;
    }

#+end_src

We focus on the _create_ method here becuase the call to
_speaker.persist()_ was the reason for all the headache.

But we are still in coding mode and last but not least we define our
_SpeakerResource_ class, again everything not relevant for
understanding the problem was removed:

#+begin_src java
@Path("/speaker")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class SpeakerResource {

    @Inject
    SpeakerService service;

    @POST
    @Transactional
    public Speaker create(Speaker newSpeaker) {
        service.create(newSpeaker);
        return newSpeaker;
    }
}
#+end_src

Root path for our _SpeakerResource_ is _/speaker_. We inject the
_SpeakerService_ and define a method for creating a _Speaker_. We
would like to be able to send _@Post_ requests to this endpoint, [[https://javaee.github.io/jsonb-spec/][Jsonb]]
or[[https://github.com/FasterXML/jackson][ Jackson]] whatever we currently prever, will deserialize the Json
body in a _Speaker_ for us.

Spendid, time to switch from coding mode to testing.

We launch that Quarkus application in devloper mode

#+begin_src sh
mvn quarkus:dev
#+end_src

Quarkus is so friendly and provides a swagger-ui in dev mode for testing
our endpoint. Super, duper lets call the _create_ endpoint via Swagger:

[[file:/Java/images/swagger_post_500.png]]

BOOM, 500 internal server error. And a beautiful Java exception:

#+begin_src text
org.jboss.resteasy.spi.UnhandledException: javax.persistence.PersistenceException: org.hibernate.PersistentObjectException: detached entity passed to persist: org.acme.conference.speaker.Speaker
#+end_src

What? Detached entity what does this mean and why?

* Enlightenment

Behind the scences Panache / Hibernate uses a so called EntityManager
for managing entities. An Entity basically has the following states:

- NEW: The entity object was just created and is not persistet to the database
- MANAGED: After call to _entitymanager.persist()_ or in our case
  _newSpeaker.persist()_ the entity is stored in the database and in
  the _managed_ state.
- REMOVED: The entity is removed from the database. And finally
- DETACHED: The Entity was detached from the EntityManager, e.g. by calling _entitymanager.detach()_ or _entitymanager.close()_.

Ok, cool but why the hell is our _Speaker_ entity in the detached
state? It was just created and never saved to the database before!

After checking the database (was empty), playing around with injecting
the EntityManager into the service and explicitly calling
_entitymanger.merge()_ which returns a new entity in the managed state
(worked, but why is this not used in the example?), I finally started
my Java debugger of choice (IntellJ, but use whatever fit's your
needs. I'm to old for IDE vs Editor and Editor vs Editor wars).

So looking at the _Speaker_ entity before calling _persist()_ revealed the following:

[[file:/Java/images/speaker_object_debugger.png]]

After playing around with _EntityManager_ and calling _merge()_ on the
speaker object, the new _Speaker_ returned by calling
_entitymanager.merge()_ looks like this in the debugger:

[[file:/Java/images/speaker_object_entitymanager_debugger.png]]

Notice that in the first debugger screenshot showing the _Speaker_
object passed into _create()_ the Id is 0 and all the internal
Hibernate fields are set to null. So this seem to be an indicator that
this _Speaker_ object is currently not attached to an _EntityManager_.

On the other side _newSpeaker_ is an Id of 1 and some those special
Hibernate fields starting with $$ have a value assigned.

And the Id already assigned to the original _Speaker_ object,
deserialized form the JSON we passed via Swagger is actually the
reason for the beautiful exception above.

* Explanation





So after a little bit of internet search magic a detached entity means
that

-

{{% notice note %}}
this is a notice
{{% /notice %}}

NOTE: test

: this is a text


#+begin_src java
bla
#+end_src

| :note: bla |
|------------|

#+begin_src java :results output
  public class Main { <1>
      public static void main(String[] args) {
          System.out.print("hello, world");
      }
  }
#+end_src
<1> test

#+begin_src emacs-lisp
(message "Hello world")
#+end_src

{{% notice warning %}}
Warning
{{% /notice %}}

{{% notice note %}}
Note
{{% /notice %}}

{{% notice caution %}}
Caution
{{% /notice %}}

{{% notice tip %}}
Tip
{{% /notice %}}

{{% notice important %}}
Important
{{% /notice %}}
